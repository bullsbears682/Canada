import { DataSourceManager } from './core/DataSourceManager';
import { DataValidationService } from './services/DataValidationService';
import { DataSynchronizationService } from './services/DataSynchronizationService';
import { DataMonitoringService } from './services/DataMonitoringService';
import { StatsCanDataSource } from './sources/StatsCanDataSource';
import { CMHCDataSource } from './sources/CMHCDataSource';
import { BankOfCanadaDataSource } from './sources/BankOfCanadaDataSource';
import { getDataSourceConfig } from './config/dataSourceConfig';
import { 
  HousingData, 
  EconomicIndicators, 
  UtilityRates,
  GovernmentBenefit,
  TaxRates,
  CostOfLivingData,
  SalaryRequirement,
  CanadianLocation,
  Province
} from './types';
import { ConfigValidator, PerformanceMonitor, CacheManager } from "./utils";

/**
 * üá®üá¶ Data Service Orchestrator
 * 
 * Main orchestrator that coordinates all data services for the Canadian
 * Cost of Living Analyzer. Provides a unified interface for data access,
 * validation, synchronization, and monitoring.
 */
export class DataServiceOrchestrator {
  private dataSourceManager: DataSourceManager;
  private validationService: DataValidationService;
  private syncService: DataSynchronizationService;
  private monitoringService: DataMonitoringService;
  private cacheManager: CacheManager;
  private isInitialized: boolean = false;

  constructor() {
    this.dataSourceManager = new DataSourceManager();
    this.validationService = new DataValidationService();
    this.syncService = new DataSynchronizationService(this.dataSourceManager);
    this.monitoringService = new DataMonitoringService(
      this.dataSourceManager,
      this.syncService
    this.cacheManager = new CacheManager();
    );
  }

  /**
   * Initialize the data service orchestrator
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      console.log('üîÑ Data service orchestrator is already initialized');
      return;
    }

    console.log('üöÄ Initializing data service orchestrator...');

    try {
      // Initialize data sources
      await this.initializeDataSources();

      // Start services
      await this.startServices();

      this.isInitialized = true;
      console.log('‚úÖ Data service orchestrator initialized successfully');

    } catch (error) {
      console.error('‚ùå Failed to initialize data service orchestrator:', error);
      throw error;
    }
  }

  /**
   * Initialize all data sources
   */
  private async initializeDataSources(): Promise<void> {
    console.log('üîß Initializing data sources...');

    // Initialize Statistics Canada
    const statsCanConfig = getDataSourceConfig('stats-can');
    if (statsCanConfig && statsCanConfig.apiKey) {
      const statsCan = new StatsCanDataSource(statsCanConfig.apiKey);
      this.dataSourceManager.registerDataSource('stats-can', statsCan, statsCanConfig);
      console.log('‚úÖ Statistics Canada data source initialized');
    } else {
      console.warn('‚ö†Ô∏è  Statistics Canada API key not configured');
    }

    // Initialize CMHC
    const cmhcConfig = getDataSourceConfig('cmhc');
    if (cmhcConfig && cmhcConfig.apiKey) {
      const cmhc = new CMHCDataSource(cmhcConfig.apiKey);
      this.dataSourceManager.registerDataSource('cmhc', cmhc, cmhcConfig);
      console.log('‚úÖ CMHC data source initialized');
    } else {
      console.warn('‚ö†Ô∏è  CMHC API key not configured');
    }

    // Initialize Bank of Canada
    const bankOfCanadaConfig = getDataSourceConfig('bank-of-canada');
    if (bankOfCanadaConfig && bankOfCanadaConfig.apiKey) {
      const bankOfCanada = new BankOfCanadaDataSource(bankOfCanadaConfig.apiKey);
      this.dataSourceManager.registerDataSource('bank-of-canada', bankOfCanada, bankOfCanadaConfig);
      console.log('‚úÖ Bank of Canada data source initialized');
    } else {
      console.warn('‚ö†Ô∏è  Bank of Canada API key not configured');
    }

    console.log(`‚úÖ Initialized data sources`);
  }

  /**
   * Start all data services
   */
  private async startServices(): Promise<void> {
    console.log('üöÄ Starting data services...');

    // Start synchronization service
    await this.syncService.start();
    console.log('‚úÖ Data synchronization service started');

    // Start monitoring service
    await this.monitoringService.start();
    console.log('‚úÖ Data monitoring service started');

    console.log('‚úÖ All data services started successfully');
  }

  /**
   * Stop all data services
   */
  async shutdown(): Promise<void> {
    if (!this.isInitialized) {
      console.log('üîÑ Data service orchestrator is not running');
      return;
    }

    console.log('üõë Shutting down data service orchestrator...');

    try {
      // Stop monitoring service
      await this.monitoringService.stop();
      console.log('‚úÖ Data monitoring service stopped');

      // Stop synchronization service
      await this.syncService.stop();
      console.log('‚úÖ Data synchronization service stopped');

      this.isInitialized = false;
      console.log('‚úÖ Data service orchestrator shut down successfully');

    } catch (error) {
      console.error('‚ùå Error during shutdown:', error);
      throw error;
    }
  }

  /**
   * Get housing data for a specific location
   */
  async getHousingData(location: CanadianLocation): Promise<HousingData> {
    this.ensureInitialized();

    try {
      // Try to get data from primary source (StatsCan)
      const housingData = await this.dataSourceManager.fetchData<HousingData>(
        'stats-can',
        'housing',
        { postalCode: location.postalCode }
      );

      // Validate the data
      const validationResult = this.validationService.validateHousingData(housingData);
      if (!validationResult.isValid) {
        console.warn(`‚ö†Ô∏è  Housing data validation warnings for ${location.postalCode}:`, validationResult.warnings);
      }

      return housingData;

    } catch (error) {
      console.error(`‚ùå Failed to fetch housing data for ${location.postalCode}:`, error);
      
      // Fallback to CMHC if StatsCan fails
      try {
        const fallbackData = await this.dataSourceManager.fetchData<HousingData>(
          'cmhc',
          'housing',
          { postalCode: location.postalCode }
        );
        
        console.log(`‚úÖ Retrieved fallback housing data from CMHC for ${location.postalCode}`);
        return fallbackData;

      } catch (fallbackError) {
        console.error(`‚ùå Fallback housing data also failed for ${location.postalCode}:`, fallbackError);
        throw new Error(`Unable to retrieve housing data for ${location.postalCode}`);
      }
    }
  }

  /**
   * Get economic indicators
   */
  async getEconomicIndicators(): Promise<EconomicIndicators> {
    this.ensureInitialized();

    try {
      // Get data from Bank of Canada (primary source for economic data)
      const economicData = await this.dataSourceManager.fetchData<EconomicIndicators>(
        'bank-of-canada',
        'economic',
        {}
      );

      // Validate the data
      const validationResult = this.validationService.validateEconomicIndicators(economicData);
      if (!validationResult.isValid) {
        console.warn('‚ö†Ô∏è  Economic data validation warnings:', validationResult.warnings);
      }

      return economicData;

    } catch (error) {
      console.error('‚ùå Failed to fetch economic indicators:', error);
      throw new Error('Unable to retrieve economic indicators');
    }
  }

  /**
   * Get utility rates for a specific location
   */
  async getUtilityRates(location: CanadianLocation): Promise<UtilityRates> {
    this.ensureInitialized();

    try {
      // Try to get utility rates from provincial sources
      const utilityData = await this.dataSourceManager.fetchData<UtilityRates>(
        'ontario-energy-board', // This would be configured based on province
        'utilities',
        { province: location.province, city: location.city }
      );

      // Validate the data
      const validationResult = this.validationService.validateUtilityRates(utilityData);
      if (!validationResult.isValid) {
        console.warn(`‚ö†Ô∏è  Utility rates validation warnings for ${location.city}:`, validationResult.warnings);
      }

      return utilityData;

    } catch (error) {
      console.error(`‚ùå Failed to fetch utility rates for ${location.city}:`, error);
      throw new Error(`Unable to retrieve utility rates for ${location.city}`);
    }
  }

  /**
   * Get government benefits information
   */
  async getGovernmentBenefits(province: Province): Promise<GovernmentBenefit[]> {
    this.ensureInitialized();

    try {
      // Get benefits data from ESDC
      const benefitsData = await this.dataSourceManager.fetchData<GovernmentBenefit[]>(
        'esdc',
        'benefits',
        { province }
      );

      // Validate each benefit
      const validatedBenefits: GovernmentBenefit[] = [];
      for (const benefit of benefitsData) {
        const validationResult = this.validationService.validateGovernmentBenefits([benefit]);
        if (validationResult.isValid) {
          validatedBenefits.push(benefit);
        } else {
          console.warn(`‚ö†Ô∏è  Benefit validation failed:`, validationResult.errors);
        }
      }

      return validatedBenefits;

    } catch (error) {
      console.error(`‚ùå Failed to fetch government benefits for ${province}:`, error);
      throw new Error(`Unable to retrieve government benefits for ${province}`);
    }
  }

  /**
   * Get tax information for a specific location
   */
  async getTaxInformation(location: CanadianLocation): Promise<TaxRates> {
    this.ensureInitialized();

    try {
      // Get tax data from CRA
      const taxData = await this.dataSourceManager.fetchData<TaxRates>(
        'cra',
        'tax',
        { province: location.province, year: new Date().getFullYear() }
      );

      // Validate the data
      const validationResult = this.validationService.validateTaxInformation(taxData);
      if (!validationResult.isValid) {
        console.warn(`‚ö†Ô∏è  Tax information validation warnings for ${location.province}:`, validationResult.warnings);
      }

      return taxData;

    } catch (error) {
      console.error(`‚ùå Failed to fetch tax information for ${location.province}:`, error);
      throw new Error(`Unable to retrieve tax information for ${location.province}`);
    }
  }

  /**
   * Calculate cost of living for a specific location
   */
  async calculateCostOfLiving(location: CanadianLocation, householdSize: number = 1): Promise<CostOfLivingData> {
    this.ensureInitialized();

    try {
      console.log(`üßÆ Calculating cost of living for ${location.city}, ${location.province}...`);

      // Fetch all required data
      const [housingData, economicData, utilityData, taxData] = await Promise.all([
        this.getHousingData(location),
        this.getEconomicIndicators(),
        this.getUtilityRates(location),
        this.getTaxInformation(location)
      ]);

      // Calculate cost of living breakdown
      const costOfLiving = this.calculateCostBreakdown(
        location,
        housingData,
        economicData,
        utilityData,
        taxData,
        householdSize
      );

      console.log(`‚úÖ Cost of living calculation completed for ${location.city}`);
      return costOfLiving;

    } catch (error) {
      console.error(`‚ùå Failed to calculate cost of living for ${location.city}:`, error);
      throw new Error(`Unable to calculate cost of living for ${location.city}`);
    }
  }

  /**
   * Calculate required salary for a specific location and lifestyle
   */
  async calculateRequiredSalary(
    location: CanadianLocation, 
    lifestyle: 'basic' | 'comfortable' | 'luxury' = 'comfortable',
    householdSize: number = 1
  ): Promise<SalaryRequirement> {
    this.ensureInitialized();

    try {
      // Get cost of living data
      const costOfLiving = await this.calculateCostOfLiving(location, householdSize);

      // Calculate salary requirements based on lifestyle
      const salaryRequirements = this.calculateSalaryRequirements(costOfLiving, lifestyle, householdSize);

      return salaryRequirements;

    } catch (error) {
      console.error(`‚ùå Failed to calculate required salary for ${location.city}:`, error);
      throw new Error(`Unable to calculate required salary for ${location.city}`);
    }
  }

  /**
   * Get system health status
   */
  getSystemHealth(): any {
    this.ensureInitialized();
    return this.monitoringService.getSystemHealthStatus();
  }

  /**
   * Get detailed health status for all data sources
   */
  getAllSourcesHealth(): any {
    this.ensureInitialized();
    return this.monitoringService.getAllSourcesHealthStatus();
  }

  /**
   * Get synchronization status
   */
  getSyncStatus(): any {
    this.ensureInitialized();
    return this.syncService.getSyncStatus();
  }

  /**
   * Force synchronization of all data sources
   */
  async forceSyncAll(): Promise<void> {
    this.ensureInitialized();
    await this.syncService.forceSyncAll();
  }

  /**
   * Get data quality metrics
   */
  getDataQuality(): any {
    this.ensureInitialized();
    return this.validationService.getOverallDataQuality();
  }

  /**
   * Ensure the orchestrator is initialized
   */
  private ensureInitialized(): void {
    if (!this.isInitialized) {
      throw new Error('Data service orchestrator is not initialized. Call initialize() first.');
    }
  }

  /**
   * Calculate cost breakdown from various data sources
   */
  private calculateCostBreakdown(
    location: CanadianLocation,
    housingData: HousingData,
    economicData: EconomicIndicators,
    utilityData: UtilityRates,
    taxData: TaxRates,
    householdSize: number
  ): CostOfLivingData {
    // Calculate monthly housing costs
    const monthlyHousingCost = this.calculateMonthlyHousingCost(housingData, economicData);

    // Calculate monthly utility costs
    const monthlyUtilityCost = this.calculateMonthlyUtilityCost(utilityData, householdSize);

    // Calculate monthly tax burden
    const monthlyTaxBurden = this.calculateMonthlyTaxBurden(taxData);

    // Calculate other living costs (food, transportation, etc.)
    const otherLivingCosts = this.calculateOtherLivingCosts(householdSize);

    const totalMonthlyCost = monthlyHousingCost + monthlyUtilityCost + monthlyTaxBurden + otherLivingCosts;

    return {
      location,
      housing: {
        mortgage: monthlyHousingCost * 0.7, // Assume 70% is mortgage/rent
        rent: housingData.rental.averageRent || 0,
        utilities: monthlyUtilityCost,
        propertyTax: monthlyTaxBurden
      },
      transportation: {
        publicTransit: 120 * householdSize,
        gas: 80 * householdSize,
        insurance: 150 * householdSize,
        maintenance: 50 * householdSize
      },
      food: {
        groceries: 300 * householdSize,
        diningOut: 100 * householdSize
      },
      healthcare: {
        insurance: 50 * householdSize,
        prescriptions: 30 * householdSize,
        dental: 20 * householdSize
      },
      other: {
        entertainment: 150 * householdSize,
        clothing: 100 * householdSize,
        personalCare: 50 * householdSize
      },
      total: totalMonthlyCost,
      lastUpdated: new Date(),
      source: 'DataServiceOrchestrator'
    };
  }

  /**
   * Calculate monthly housing costs
   */
  private calculateMonthlyHousingCost(housingData: HousingData, economicData: EconomicIndicators): number {
    // For now, use rental costs as they're more predictable
    // In a real implementation, this would consider mortgage vs rental scenarios
    const baseRent = housingData.rental.averageRent || 0;
    
    // Adjust for current interest rates if considering buying
    const interestRateAdjustment = economicData.interestRates.policyRate / 100;
    
    return baseRent * (1 + interestRateAdjustment * 0.1); // Rough adjustment
  }

  /**
   * Calculate monthly utility costs
   */
  private calculateMonthlyUtilityCost(utilityData: UtilityRates, householdSize: number): number {
    // UtilityRates has residentialRate, commercialRate, deliveryCharge, serviceCharge
    // Use residential rates for household calculations
    const electricityCost = (utilityData.electricity.residentialRate * 800) * householdSize; // 800 kWh per person
    const gasCost = (utilityData.naturalGas.residentialRate * 50) * householdSize; // 50 m¬≥ per person
    const waterCost = (utilityData.water.residentialRate * 10) * householdSize; // 10 m¬≥ per person
    
    // Add delivery and service charges
    const deliveryCharges = utilityData.electricity.deliveryCharge + utilityData.naturalGas.deliveryCharge + utilityData.water.serviceCharge;
    
    return electricityCost + gasCost + waterCost + deliveryCharges;
  }

  /**
   * Calculate monthly tax burden
   */
  private calculateMonthlyTaxBurden(taxData: TaxRates): number {
    // Simplified calculation - in reality this would be much more complex
    // TaxRates has federal.gst, provincial.pst, municipal.propertyTax
    const gst = taxData.federal.gst / 100;
    const pst = taxData.provincial.pst ? taxData.provincial.pst / 100 : 0;
    const propertyTax = taxData.municipal.propertyTax / 100;
    
    // Assume average household income of $80,000 and property value of $500,000
    const averageIncome = 80000;
    const monthlyIncome = averageIncome / 12;
    const propertyValue = 500000;
    
    const incomeTax = monthlyIncome * (gst + pst);
    const propertyTaxMonthly = (propertyValue * propertyTax) / 12;
    
    return incomeTax + propertyTaxMonthly;
  }

  /**
   * Calculate other living costs
   */
  private calculateOtherLivingCosts(householdSize: number): number {
    // Simplified calculation - in reality this would use actual cost data
    const baseCosts = {
      food: 400,
      transportation: 200,
      healthcare: 100,
      entertainment: 150,
      miscellaneous: 100
    };

    const totalBaseCosts = Object.values(baseCosts).reduce((sum, cost) => sum + cost, 0);
    
    // Adjust for household size
    const householdMultiplier = Math.sqrt(householdSize); // Economies of scale
    
    return totalBaseCosts * householdMultiplier;
  }

  /**
   * Calculate salary requirements based on cost of living and lifestyle
   */
  private calculateSalaryRequirements(
    costOfLiving: CostOfLivingData, 
    lifestyle: 'basic' | 'comfortable' | 'luxury',
    householdSize: number
  ): SalaryRequirement {
    const monthlyCost = costOfLiving.total;
    
    // Lifestyle multipliers
    const lifestyleMultipliers = {
      basic: 1.0,
      comfortable: 1.3,
      luxury: 2.0
    };

    const multiplier = lifestyleMultipliers[lifestyle];
    const adjustedMonthlyCost = monthlyCost * multiplier;
    
    // Calculate required annual salary (assuming 30% goes to taxes and savings)
    const requiredAnnualSalary = adjustedMonthlyCost * 12 / 0.7;
    
    // Calculate monthly take-home (70% of salary after taxes)
    const monthlyTakeHome = requiredAnnualSalary * 0.7 / 12;
    
    // Calculate affordability score (how well the salary covers costs)
    const affordabilityScore = Math.min(1.0, monthlyTakeHome / adjustedMonthlyCost);
    
    return {
      location: costOfLiving.location,
      lifestyle,
      familySize: householdSize,
      annualSalary: requiredAnnualSalary,
      monthlyTakeHome,
      affordabilityScore,
      breakdown: {
        housing: costOfLiving.housing.mortgage + costOfLiving.housing.rent + costOfLiving.housing.utilities + costOfLiving.housing.propertyTax,
        transportation: costOfLiving.transportation.publicTransit + costOfLiving.transportation.gas + costOfLiving.transportation.insurance + costOfLiving.transportation.maintenance,
        food: costOfLiving.food.groceries + costOfLiving.food.diningOut,
        healthcare: costOfLiving.healthcare.insurance + costOfLiving.healthcare.prescriptions + costOfLiving.healthcare.dental,
        other: costOfLiving.other.entertainment + costOfLiving.other.clothing + costOfLiving.other.personalCare,
        savings: monthlyTakeHome - adjustedMonthlyCost
      },
      lastUpdated: new Date(),
      source: 'DataServiceOrchestrator'
    };
  }
}